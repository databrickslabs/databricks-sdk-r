# Code generated from OpenAPI specs by Databricks SDK Generator. DO NOT EDIT.{{if .IsAccounts}}{{skipThisFile}}{{end}}

{{range .Methods}}{{.Comment "#' " 80}}
{{if .Request}}#'{{range .Request.Fields}}
#' @param {{.SnakeName}} {{.Summary}}{{end}}
{{end -}}
{{.Service.SnakeName}}_{{.SnakeName}} <- function(
    {{- if .Request}}{{range .Request.RequiredFields}}{{.SnakeName}}, {{end -}}
    {{- range .Request.NonRequiredFields}}{{.SnakeName}} = NULL, 
    {{end}}{{- end -}}{{if and .Wait (not .IsCrudRead)}}timeout={{.Wait.Timeout}}, callback = cli_reporter, {{end}}...) {
    {{template "method-serialize" .}}
    {{template "method-call" .}}
}

{{end}}

{{define "method-serialize" -}}
    {{if .Request}}
    {{- if .Request.HasQueryField}}query <- list({{range .Request.Fields}}{{if .IsQuery}}
        {{.Name}} = {{.SnakeName}}, {{end}}{{end}}...){{end}}
    {{- if .Request.HasJsonField}}body <- list({{range .Request.Fields}}{{if .IsJson}}
        {{.Name}} = {{.SnakeName}}, {{end}}{{end}}...){{end}}
    {{end -}}
{{- end}}

{{define "method-call" -}}
    {{if .Pagination -}}{{template "method-call-paginated" .}}
    {{- else if and .Wait (not .IsCrudRead) -}}{{template "method-call-retried" .}}
    {{- else}}{{template "method-call-default" .}}{{end}}
{{- end}}

{{define "method-call-paginated" -}}
    {{if .Pagination.MultiRequest}}
    {{if and .Pagination.Offset (not (eq .Path "/api/2.0/clusters/events")) }}
    query${{.Pagination.Offset.Name}} = {{if eq .Pagination.Increment 1}}1{{else}}0{{end}}{{end}}
    results <- data.frame()
    while (TRUE) {
        json <- {{template "method-do" .}}
        if (is.null(nrow(json${{.Pagination.Results.Name}}))) {
            break
        }
        # append this page of results to one results data.frame
        results <- dplyr::bind_rows(results, json${{.Pagination.Results.Name}})
        {{if eq .Path "/api/2.0/clusters/events" -}}
        if (is.null(json$next_page)) {
            break
        }
        body <- json$next_page
        {{- else if .Pagination.Token -}}
        if (is.null(json${{.Pagination.Token.Bind.Name}})) {
            break
        }
        {{if eq "GET" .Verb}}query{{else}}body{{end}}${{.Pagination.Token.PollField.Name}} <- json${{.Pagination.Token.Bind.Name}}
        {{- else if eq .Pagination.Increment 1 -}}
        query${{.Pagination.Offset.Name}} <- query${{.Pagination.Offset.Name}} + 1
        {{- else -}}
        query${{.Pagination.Offset.Name}} <- query${{.Pagination.Offset.Name}} + nrow(json${{.Pagination.Results.Name}})
        {{- end}}
    }
    {{if .Pagination.NeedsOffsetDedupe -}}
    # de-duplicate any records via {{.Pagination.Entity.IdentifierField.Name}} column
    results <- results[!duplicated(results${{.Pagination.Entity.IdentifierField.Name}}), ]
    {{end -}}
    return (results)
    {{else}}
    json <- {{template "method-do" .}}
    return (json{{if .Pagination.Results}}${{.Pagination.Results.Name}}{{end}})
    {{end}}
{{- end}}

{{define "method-call-retried" -}}
    {{if .Response}}op_response <- {{end}}{{template "method-do" .}}
    started <- as.numeric(Sys.time())
    target_states <- c({{range .Wait.Success}}"{{.Content}}", {{end}}c()){{if .Wait.Failure}}
    failure_states <- c({{range .Wait.Failure}}"{{.Content}}", {{end}}c()){{end}}
    status_message <- 'polling...'
    attempt <- 1
    while ((started + (timeout*60)) > as.numeric(Sys.time())) {
        poll <- {{.Service.SnakeName}}_{{.Wait.Poll.SnakeName}}({{range $i, $b := .Wait.Binding}}{{if $i}}, {{end -}}
            {{$b.PollField.SnakeName}} = {{if $b.IsResponseBind}}op_response${{$b.Bind.Name}}{{else}}{{$b.Bind.SnakeName}}{{end}}
        {{- end}})
        status <- poll{{range .Wait.StatusPath}}${{.SnakeName}}{{end}}
        {{if .Wait.ComplexMessagePath -}}
        status_message <- paste("current status:", status)
        if (!is.null(poll${{.Wait.MessagePathHead.SnakeName}})) {
            status_message <- poll{{range .Wait.MessagePath}}${{.SnakeName}}{{end}}
        }
        {{- else if .Wait.MessagePath -}}
        status_message <- poll{{range .Wait.MessagePath}}${{.SnakeName}}{{end}}
        {{- else -}}
        status_message <- paste("current status:", status)
        {{- end}}
        if (status %in% target_states) {
            if (!is.null(callback)) {
                callback(paste0(status, ": ", status_message), done=TRUE)
            }
            return (poll)
        }
        {{if .Wait.Failure -}}
        if (status %in% failure_states) {
            msg <- paste("failed to reach {{range $i, $e := .Wait.Success}}{{if $i}} or {{end}}{{$e.Content}}{{end}}, got ", status, "-", status_message)
            rlang::abort(msg, call = rlang::caller_env())
        }
        {{end}}prefix <- paste0("databricks::{{.Service.SnakeName}}_{{.Wait.Poll.SnakeName}}({{range $i, $b := .Wait.Binding}}{{if $i}}, "{{end -}}
            {{$b.PollField.SnakeName}}=", {{if $b.IsResponseBind}}op_response${{$b.Bind.Name}}{{else}}{{$b.Bind.SnakeName}}{{end}}
        {{- end}}, ")")
        sleep <- attempt
        if (sleep > 10) {
            # sleep 10s max per attempt
            sleep <- 10
        }
        if (!is.null(callback)) {
            callback(paste0(status, ": ", status_message), done=FALSE)
        }
        random_pause <- runif(1, min = 0.1, max = 0.5)
        Sys.sleep(sleep + random_pause)
        attempt <- attempt + 1
    }
    msg <- paste("timed out after", timeout, "minutes:", status_message)
    rlang::abort(msg, call = rlang::caller_env())
{{- end}}

{{define "method-call-default" -}}
    {{template "method-do" .}}
{{- end}}

{{define "method-do" -}}
.api$do("{{.Verb}}", {{if .PathParts -}}paste({{range  .PathParts}}"{{.Prefix}}", {{if .Field}}{{.Field.SnakeName}}{{else if .IsAccountId}}.api$account_id{{end}}, {{ end }}sep = "")
    {{- else}}"{{.Path}}"{{end}}{{if .Request}}{{if .Request.HasQueryField}}, query = query{{end}}{{if .Request.HasJsonField}}, body = body{{end}}{{end}})
{{- end}}